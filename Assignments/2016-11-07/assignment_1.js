// Generated by CoffeeScript 1.11.1
var Point, a, anchor, area_of_triangle, b, c, compare_by_angle, convex_hull_graham_scan, j, len, orientation_test, p, point_inside_triangle, point_inside_triangle_baricentric, points, q, r, radial_sort, result, squared_distance, swap;

Point = (function() {
  Point.prototype.x = 0.0;

  Point.prototype.y = 0.0;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  return Point;

})();

area_of_triangle = function(a, b, c, abs, divide) {
  var res;
  if (abs == null) {
    abs = true;
  }
  if (divide == null) {
    divide = true;
  }
  console.log(a, b, c);
  res = (a.x * b.y) + (a.y * c.x) + (b.x * c.y) - (b.y * c.x) - (c.y * a.x) - (b.x * a.y);
  if (divide === true) {
    res = (1 / 2) * res;
  }
  if (abs === true) {
    res = Math.abs(res);
  }
  console.log("area: ", res);
  return res;
};

swap = function(list, index_1, index_2) {
  var temp;
  temp = list[index_1];
  list[index_1] = list[index_2];
  return list[index_2] = temp;
};

squared_distance = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

orientation_test = function(p, q, r) {
  var determinant;
  determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
  return determinant;
};

console.log("\nTest orientation_test");

p = new Point(3, 1);

q = new Point(4, 3);

r = new Point(10, 2);

console.log(p, q, r);

result = orientation_test(p, q, r);

console.log(result);

switch (result) {
  case 0:
    console.log("r is on the same line as p and q");
    break;
  case 1:
    console.log("r is on the left of p and q");
    break;
  default:
    console.log("r is on the right of p and q");
}

compare_by_angle = function(anchor, a, b) {
  var orientation;
  orientation = orientation_test(anchor, a, b);
  if (orientation === 0) {
    if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
      return true;
    } else {
      return false;
    }
  } else if (orientation < 0) {
    return true;
  } else {
    return false;
  }
};

console.log("\nTest compare");

anchor = new Point(0, 0);

a = new Point(4, -2);

b = new Point(2, 2);

console.log(anchor, a, b);

result = compare_by_angle(anchor, a, b);

if (result === false) {
  console.log("a is smaller than b");
} else {
  console.log("a is bigger than b");
}

point_inside_triangle = function(a, b, c, p) {
  var abs, b1, b2, b3, divide;
  if (area_of_triangle(a, b, c, divide = false, abs = false) === 0) {
    return false;
  }
  b1 = orientation_test(a, b, p) > 0;
  b2 = orientation_test(b, c, p) > 0;
  b3 = orientation_test(c, a, p) > 0;
  return (b1 === b2) && (b2 === b3);
};

console.log("\nTest point_inside_triangle");

a = new Point(-3, 1);

b = new Point(1, 5);

c = new Point(3, 1);

p = new Point(10, 2);

console.log("abc: ", a, b, c);

console.log("p: ", p);

console.log(point_inside_triangle(a, b, c, p));

point_inside_triangle_baricentric = function(a, b, c, p) {
  var alfa, area_abc, beta, gamma;
  area_abc = area_of_triangle(a, b, c);
  if (area_abc === 0) {
    return false;
  }
  alfa = area_of_triangle(p, b, c);
  beta = area_of_triangle(p, a, c);
  gamma = area_of_triangle(p, a, b);
  return alfa + beta + gamma === area_abc;
};

console.log("\nTest point_inside_baricentric");

console.log(point_inside_triangle_baricentric(a, b, c, p));

points = [new Point(1, 1), new Point(-2, 1), new Point(-1, 3), new Point(2, 1), new Point(2, -2), new Point(-1, -2), new Point(2, 1)];

for (j = 0, len = points.length; j < len; j++) {
  p = points[j];
  p.x -= anchor.x;
  p.y -= anchor.y;
}

radial_sort = function(points, anchor, cw) {
  if (points.length === 0) {
    return [];
  }
  if (anchor == null) {
    anchor = new Point(points[0].x, points[0].y);
  }
  if (cw == null) {
    cw = true;
  }
  points.sort(function(a, b) {
    var orientation;
    if (a.x - anchor.x === 0 && a.y - anchor.y === 0 && b.x - anchor.x !== 0 && b.y - anchor.y !== 0) {
      return -1;
    }
    if (a.x - anchor.x !== 0 && a.y - anchor.y !== 0 && b.x - anchor.x === 0 && b.y - anchor.y === 0) {
      return 1;
    }
    if (a.x - anchor.x >= 0 && b.x - anchor.x < 0) {
      return -1;
    }
    if (a.x - anchor.x < 0 && b.x - anchor.x >= 0) {
      return 1;
    }
    if (a.x - anchor.x === 0 && b.x - anchor.x === 0) {
      if (a.y - anchor.y < 0 && b.y - anchor.y < 0) {
        if (a.y < b.y) {
          return 1;
        } else {
          return -1;
        }
      } else {
        if (a.y > b.y) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    orientation = orientation_test(anchor, a, b);
    if (orientation === 0) {
      if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if (orientation > 0) {
        return 1;
      } else {
        return -1;
      }
    }
  });
  if (!cw) {
    points.reverse();
  }
  return points;
};

console.log("\nTesting radial sort");

console.log(points);

radial_sort(points, anchor = new Point(0, 0));

console.log(points);

points = [new Point(-1, 3), new Point(-1, -2), new Point(2, -2), new Point(2, 1), new Point(1, 1), new Point(-2, 1), new Point(4, -2), new Point(0, 0)];

console.log(points);

convex_hull_graham_scan = function(input_points) {
  var convex_hull, cw, i, k, l, ref, ref1, smallest_x_point_index;
  points = input_points.slice();
  convex_hull = [];
  smallest_x_point_index = 0;
  for (i = k = 0, ref = points.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
    if ((points[i].x < points[smallest_x_point_index].x) || ((points[i].x === points[smallest_x_point_index].x) && (points[i].y < points[smallest_x_point_index].y))) {
      smallest_x_point_index = i;
    }
  }
  swap(points, 0, smallest_x_point_index);
  anchor = new Point(points[0].x, points[0].y);
  points = [anchor].concat(radial_sort(points.slice(1), anchor, cw = false));
  console.log("sorted: \n", points);
  i = 1;
  while (i < points.length - 1 && (orientation_test(anchor, points[i], points[i + 1]) === 0)) {
    points.splice(i, 1);
  }
  console.log("sorted2: \n", points);
  if (points.length < 3) {
    return [];
  }
  convex_hull.push(new Point(points[0].x, points[0].y));
  convex_hull.push(new Point(points[1].x, points[1].y));
  convex_hull.push(new Point(points[2].x, points[2].y));
  for (i = l = 3, ref1 = points.length - 1; 3 <= ref1 ? l <= ref1 : l >= ref1; i = 3 <= ref1 ? ++l : --l) {
    while (orientation_test(convex_hull[convex_hull.length - 2], convex_hull[convex_hull.length - 1], points[i]) <= 0) {
      if (convex_hull.length < 2) {
        console.log("alert: ", convex_hull);
      }
      convex_hull.pop();
    }
    convex_hull.push(new Point(points[i].x, points[i].y));
  }
  return convex_hull;
};

points = convex_hull_graham_scan(points);

console.log(points);

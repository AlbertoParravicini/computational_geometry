// Generated by CoffeeScript 1.11.1
(function() {
  var Point, a, anchor, area_of_triangle, b, c, compare_by_angle, convex_hull_graham_scan, orientation_test, p, point_inside_triangle, point_inside_triangle_baricentric, points, q, r, radial_sort, result, squared_distance, swap;

  Point = (function() {
    Point.prototype.x = 0.0;

    Point.prototype.y = 0.0;

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  area_of_triangle = function(a, b, c, abs, divide) {
    var res;
    if (abs == null) {
      abs = true;
    }
    if (divide == null) {
      divide = true;
    }
    console.log(a, b, c);
    res = (a.x * b.y) + (a.y * c.x) + (b.x * c.y) - (b.y * c.x) - (c.y * a.x) - (b.x * a.y);
    if (divide === true) {
      res = (1 / 2) * res;
    }
    if (abs === true) {
      res = Math.abs(res);
    }
    console.log("area: ", res);
    return res;
  };

  swap = function(list, index_1, index_2) {
    var temp;
    temp = list[index_1];
    list[index_1] = list[index_2];
    return list[index_2] = temp;
  };

  squared_distance = function(a, b) {
    return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
  };

  orientation_test = function(p, q, r) {
    var determinant;
    determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
    if (determinant === 0) {
      return 0;
    } else if (determinant > 0) {
      return 1;
    } else {
      return -1;
    }
  };

  console.log("\nTest orientation_test");

  p = new Point(3, 1);

  q = new Point(4, 3);

  r = new Point(10, 2);

  console.log(p, q, r);

  result = orientation_test(p, q, r);

  console.log(result);

  switch (result) {
    case 0:
      console.log("r is on the same line as p and q");
      break;
    case 1:
      console.log("r is on the left of p and q");
      break;
    default:
      console.log("r is on the right of p and q");
  }

  compare_by_angle = function(anchor, a, b) {
    var orientation;
    orientation = orientation_test(anchor, a, b);
    if (orientation === 0) {
      if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
        return true;
      } else {
        return false;
      }
    } else if (orientation < 0) {
      return true;
    } else {
      return false;
    }
  };

  console.log("\nTest compare");

  anchor = new Point(0, 0);

  a = new Point(4, -2);

  b = new Point(2, 2);

  console.log(anchor, a, b);

  result = compare_by_angle(anchor, a, b);

  if (result === false) {
    console.log("a is smaller than b");
  } else {
    console.log("a is bigger than b");
  }

  point_inside_triangle = function(a, b, c, p) {
    var abs, b1, b2, b3, divide;
    if (area_of_triangle(a, b, c, divide = false, abs = false) === 0) {
      return false;
    }
    b1 = orientation_test(a, b, p) === 1;
    b2 = orientation_test(b, c, p) === 1;
    b3 = orientation_test(c, a, p) === 1;
    return (b1 === b2) && (b2 === b3);
  };

  console.log("\nTest point_inside_triangle");

  a = new Point(-3, 1);

  b = new Point(1, 5);

  c = new Point(3, 1);

  p = new Point(10, 2);

  console.log("abc: ", a, b, c);

  console.log("p: ", p);

  console.log(point_inside_triangle(a, b, c, p));

  point_inside_triangle_baricentric = function(a, b, c, p) {
    var alfa, area_abc, beta, gamma;
    area_abc = area_of_triangle(a, b, c);
    if (area_abc === 0) {
      return false;
    }
    alfa = area_of_triangle(p, b, c);
    beta = area_of_triangle(p, a, c);
    gamma = area_of_triangle(p, a, b);
    return alfa + beta + gamma === area_abc;
  };

  console.log("\nTest point_inside_baricentric");

  console.log(point_inside_triangle_baricentric(a, b, c, p));

  points = [new Point(-1, 3), new Point(-1, -2), new Point(2, -2), new Point(2, 1), new Point(1, 1), new Point(-2, 1), new Point(4, -2), new Point(0, 0)];

  console.log(points);

  convex_hull_graham_scan = function(points) {
    var convex_hull, i, j, k, l, ref, ref1, ref2, smallest_y_point_index;
    convex_hull = [];
    smallest_y_point_index = 0;
    for (i = j = 0, ref = points.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if ((points[i].y < points[smallest_y_point_index].y) || ((points[i].y === points[smallest_y_point_index].y) && (points[i].x < points[smallest_y_point_index].x))) {
        smallest_y_point_index = i;
      }
    }
    swap(points, 0, smallest_y_point_index);
    anchor = points[0];
    points = [points[0]].concat(points.slice(1, +(points.length - 1) + 1 || 9e9).sort(function(a, b) {
      var orientation;
      orientation = orientation_test(anchor, a, b);
      if (orientation === 0) {
        if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
          return true;
        } else {
          return false;
        }
      } else if (orientation < 0) {
        return true;
      } else {
        return false;
      }
    }));
    for (i = k = 1, ref1 = points.length - 1; k <= ref1; i = k += 1) {
      while (i < points.length - 1 && (orientation_test(anchor, points[i], points[i + 1]) === 0)) {
        points.splice(i, 1);
      }
    }
    if (points.length < 3) {
      return [];
    }
    convex_hull.push(points[0]);
    convex_hull.push(points[1]);
    convex_hull.push(points[2]);
    for (i = l = 3, ref2 = points.length - 1; 3 <= ref2 ? l <= ref2 : l >= ref2; i = 3 <= ref2 ? ++l : --l) {
      while (orientation_test(convex_hull[convex_hull.length - 2], convex_hull[convex_hull.length - 1], points[i]) !== 1) {
        convex_hull.pop();
      }
      convex_hull.push(points[i]);
    }
    return convex_hull;
  };

  points = convex_hull_graham_scan(points);

  console.log(points);

  points = [new Point(1, 1), new Point(-2, 1), new Point(-1, 3), new Point(2, 1), new Point(2, -2), new Point(-1, -2), new Point(2, 1)];

  radial_sort = function(points, anchor, ccw) {
    if (anchor == null) {
      anchor = null;
    }
    if (ccw == null) {
      ccw = false;
    }
    if (points.length === 0) {
      return [];
    }
    if (anchor === null) {
      anchor = points[0];
    }
    points.sort(function(a, b) {
      var orientation;
      if (a.x - anchor.x === 0 && a.y - anchor.y === 0) {
        return false;
      }
      if (a.x - anchor.x >= 0 && b.x - anchor.x < 0) {
        return a.y - anchor.y < 0;
      }
      if (a.y - anchor.y < 0 && b.y - anchor.y >= 0) {
        return true;
      }
      if (a.y - anchor.y >= 0 && b.y - anchor.y < 0) {
        return false;
      } else if (a.y - anchor.y === 0 && b.y - anchor.y === 0) {
        if (a.x - anchor.x >= 0 || b.x - anchor.x >= 0) {
          return a.x < b.x;
        } else {
          b.x < a.x;
        }
      }
      orientation = orientation_test(anchor, a, b);
      if (orientation === 0) {
        return squared_distance(anchor, a) >= squared_distance(anchor, b);
      } else {
        return orientation < 0;
      }
    });
    if (ccw) {
      return points.reverse();
    }
  };

  console.log("\nTesting radial sort");

  console.log(points);

  radial_sort(points, anchor = new Point(0, 0));

  console.log(points);

}).call(this);

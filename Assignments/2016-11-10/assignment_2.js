// Generated by CoffeeScript 1.11.1
var Point, binary_search, convex_hull_graham_scan, hull, inclusion_in_hull, new_point, orientation_test, point_inside_triangle, points, radial_sort, squared_distance, swap;

Point = (function() {
  Point.prototype.x = 0.0;

  Point.prototype.y = 0.0;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  return Point;

})();

swap = function(list, index_1, index_2) {
  var temp;
  temp = list[index_1];
  list[index_1] = list[index_2];
  return list[index_2] = temp;
};

squared_distance = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

orientation_test = function(p, q, r) {
  var determinant;
  determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
  return determinant;
};

point_inside_triangle = function(a, b, c, p) {
  var abs, b1, b2, b3, divide;
  if (area_of_triangle(a, b, c, divide = false, abs = false) === 0) {
    return false;
  }
  b1 = orientation_test(a, b, p) > 0;
  b2 = orientation_test(b, c, p) > 0;
  b3 = orientation_test(c, a, p) > 0;
  return (b1 === b2) && (b2 === b3);
};

radial_sort = function(points, anchor, cw) {
  if (points.length === 0) {
    return [];
  }
  if (anchor == null) {
    anchor = new Point(points[0].x, points[0].y);
  }
  if (cw == null) {
    cw = true;
  }
  points.sort(function(a, b) {
    var orientation;
    if (a.x - anchor.x === 0 && a.y - anchor.y === 0 && b.x - anchor.x !== 0 && b.y - anchor.y !== 0) {
      return -1;
    }
    if (a.x - anchor.x !== 0 && a.y - anchor.y !== 0 && b.x - anchor.x === 0 && b.y - anchor.y === 0) {
      return 1;
    }
    if (a.x - anchor.x >= 0 && b.x - anchor.x < 0) {
      return -1;
    }
    if (a.x - anchor.x < 0 && b.x - anchor.x >= 0) {
      return 1;
    }
    if (a.x - anchor.x === 0 && b.x - anchor.x === 0) {
      if (a.y - anchor.y < 0 && b.y - anchor.y < 0) {
        if (a.y < b.y) {
          return 1;
        } else {
          return -1;
        }
      } else {
        if (a.y > b.y) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    orientation = orientation_test(anchor, a, b);
    if (orientation === 0) {
      if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if (orientation > 0) {
        return 1;
      } else {
        return -1;
      }
    }
  });
  if (!cw) {
    points.reverse();
  }
  return points;
};

console.log(points);

convex_hull_graham_scan = function(input_points) {
  var anchor, convex_hull, cw, i, j, k, points, ref, ref1, smallest_x_point_index;
  points = input_points.slice();
  convex_hull = [];
  smallest_x_point_index = 0;
  for (i = j = 0, ref = points.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    if ((points[i].x < points[smallest_x_point_index].x) || ((points[i].x === points[smallest_x_point_index].x) && (points[i].y < points[smallest_x_point_index].y))) {
      smallest_x_point_index = i;
    }
  }
  swap(points, 0, smallest_x_point_index);
  anchor = new Point(points[0].x, points[0].y);
  points = [anchor].concat(radial_sort(points.slice(1), anchor, cw = false));
  i = 1;
  while (i < points.length - 1 && (orientation_test(anchor, points[i], points[i + 1]) === 0)) {
    points.splice(i, 1);
  }
  if (points.length < 3) {
    return [];
  }
  convex_hull.push(new Point(points[0].x, points[0].y));
  convex_hull.push(new Point(points[1].x, points[1].y));
  convex_hull.push(new Point(points[2].x, points[2].y));
  for (i = k = 3, ref1 = points.length - 1; 3 <= ref1 ? k <= ref1 : k >= ref1; i = 3 <= ref1 ? ++k : --k) {
    while (orientation_test(convex_hull[convex_hull.length - 2], convex_hull[convex_hull.length - 1], points[i]) <= 0) {
      convex_hull.pop();
    }
    convex_hull.push(new Point(points[i].x, points[i].y));
  }
  return convex_hull;
};

binary_search = function(list, elem) {
  var middle, start_index, stop_index;
  start_index = 0;
  stop_index = list.length - 1;
  middle = Math.floor((stop_index + start_index) / 2);
  while (list[middle] !== elem && start_index < stop_index) {
    if (elem < list[middle]) {
      stop_index = middle - 1;
    } else if (elem > list[middle]) {
      start_index = middle + 1;
    }
    middle = Math.floor((stop_index + start_index) / 2);
  }
  if (list[middle] !== elem) {
    throw new Error("Element not found!");
  }
  return middle;
};

inclusion_in_hull = function(points, new_point) {
  var middle, o1, o2, p0, start_index, stop_index;
  p0 = points[0];
  start_index = 1;
  stop_index = points.length - 1;
  middle = Math.floor((stop_index + start_index) / 2);
  while (start_index < stop_index) {
    o1 = orientation_test(p0, points[middle], new_point);
    o2 = orientation_test(p0, points[middle + 1], new_point);
    console.log(points[middle], points[middle + 1]);
    console.log(o1, o2);
    if (o1 >= 0 && o2 <= 0) {
      if (orientation_test(points[middle], points[middle + 1], new_point) > 0) {
        return [true, points[0], points[middle], points[middle + 1]];
      } else {
        return false;
      }
    } else {
      if (o1 >= 0 && o2 >= 0) {
        start_index = middle + 1;
      } else {
        stop_index = middle;
      }
    }
    middle = Math.floor((stop_index + start_index) / 2);
  }
  return false;
};

points = [new Point(-1, 3), new Point(-1, -2), new Point(2, -2), new Point(2, 1), new Point(1, 1), new Point(-2, 1), new Point(4, -2)];

new_point = new Point(-1, 2);

points = [new Point(100, 10), new Point(300, 200), new Point(423, 200), new Point(100, 300), new Point(500, 120), new Point(200, 320), new Point(50, 40), new Point(50, 350), new Point(150, 350), new Point(220, 400), new Point(240, 320), new Point(280, 450)];

new_point = new Point(153, 44);

console.log(points);

hull = convex_hull_graham_scan(points);

console.log(hull);

console.log(inclusion_in_hull(hull, new_point));

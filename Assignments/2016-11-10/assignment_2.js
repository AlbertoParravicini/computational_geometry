// Generated by CoffeeScript 1.11.1
var Point, convex_hull_graham_scan, find_intersecting_edge, find_tangents, find_tangents_bin_search, inclusion_in_hull, new_point, orientation_test, point_inside_triangle, points, radial_sort, squared_distance, swap;

Point = (function() {
  Point.prototype.x = 0.0;

  Point.prototype.y = 0.0;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  return Point;

})();

swap = function(list, index_1, index_2) {
  var temp;
  temp = list[index_1];
  list[index_1] = list[index_2];
  return list[index_2] = temp;
};

squared_distance = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

orientation_test = function(p, q, r) {
  var determinant;
  determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
  return determinant;
};

point_inside_triangle = function(a, b, c, p) {
  var abs, b1, b2, b3, divide;
  if (area_of_triangle(a, b, c, divide = false, abs = false) === 0) {
    return false;
  }
  b1 = orientation_test(a, b, p) > 0;
  b2 = orientation_test(b, c, p) > 0;
  b3 = orientation_test(c, a, p) > 0;
  return (b1 === b2) && (b2 === b3);
};

radial_sort = function(points, anchor, cw) {
  if (points.length === 0) {
    return [];
  }
  if (anchor == null) {
    anchor = new Point(points[0].x, points[0].y);
  }
  if (cw == null) {
    cw = true;
  }
  points.sort(function(a, b) {
    var orientation;
    if (a.x - anchor.x === 0 && a.y - anchor.y === 0 && b.x - anchor.x !== 0 && b.y - anchor.y !== 0) {
      return -1;
    }
    if (a.x - anchor.x !== 0 && a.y - anchor.y !== 0 && b.x - anchor.x === 0 && b.y - anchor.y === 0) {
      return 1;
    }
    if (a.x - anchor.x >= 0 && b.x - anchor.x < 0) {
      return -1;
    }
    if (a.x - anchor.x < 0 && b.x - anchor.x >= 0) {
      return 1;
    }
    if (a.x - anchor.x === 0 && b.x - anchor.x === 0) {
      if (a.y - anchor.y < 0 && b.y - anchor.y < 0) {
        if (a.y < b.y) {
          return 1;
        } else {
          return -1;
        }
      } else {
        if (a.y > b.y) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    orientation = orientation_test(anchor, a, b);
    if (orientation === 0) {
      if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if (orientation > 0) {
        return 1;
      } else {
        return -1;
      }
    }
  });
  if (!cw) {
    points.reverse();
  }
  return points;
};

console.log(points);

convex_hull_graham_scan = function(input_points) {
  var anchor, convex_hull, cw, i, j, k, points, ref, ref1, smallest_x_point_index;
  points = input_points.slice();
  convex_hull = [];
  smallest_x_point_index = 0;
  for (i = j = 0, ref = points.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    if ((points[i].x < points[smallest_x_point_index].x) || ((points[i].x === points[smallest_x_point_index].x) && (points[i].y < points[smallest_x_point_index].y))) {
      smallest_x_point_index = i;
    }
  }
  swap(points, 0, smallest_x_point_index);
  anchor = new Point(points[0].x, points[0].y);
  points = [anchor].concat(radial_sort(points.slice(1), anchor, cw = false));
  i = 1;
  while (i < points.length - 1 && (orientation_test(anchor, points[i], points[i + 1]) === 0)) {
    points.splice(i, 1);
  }
  if (points.length < 3) {
    return [];
  }
  convex_hull.push(new Point(points[0].x, points[0].y));
  convex_hull.push(new Point(points[1].x, points[1].y));
  convex_hull.push(new Point(points[2].x, points[2].y));
  for (i = k = 3, ref1 = points.length - 1; 3 <= ref1 ? k <= ref1 : k >= ref1; i = 3 <= ref1 ? ++k : --k) {
    while (orientation_test(convex_hull[convex_hull.length - 2], convex_hull[convex_hull.length - 1], points[i]) <= 0) {
      convex_hull.pop();
    }
    convex_hull.push(new Point(points[i].x, points[i].y));
  }
  return convex_hull;
};

inclusion_in_hull = function(points, new_point) {
  var middle, o1, o2, p0, start_index, stop_index;
  p0 = points[0];
  start_index = 1;
  stop_index = points.length - 1;
  middle = Math.floor((stop_index + start_index) / 2);
  while (start_index < stop_index) {
    o1 = orientation_test(p0, points[middle], new_point);
    o2 = orientation_test(p0, points[middle + 1], new_point);
    console.log(points[middle], points[middle + 1]);
    console.log(o1, o2);
    if (o1 >= 0 && o2 <= 0) {
      if (orientation_test(points[middle], points[middle + 1], new_point) > 0) {
        return [true, points[0], points[middle], points[middle + 1]];
      } else {
        return false;
      }
    } else {
      if (o1 >= 0 && o2 >= 0) {
        start_index = middle + 1;
      } else {
        stop_index = middle;
      }
    }
    middle = Math.floor((stop_index + start_index) / 2);
  }
  return false;
};

find_tangents = function(input_points, new_point) {
  var e_next, e_prev, i, j, points, ref, v_l, v_r;
  points = input_points.slice();
  if (inclusion_in_hull(points, new_point)) {
    console.log("The point ", new_point, "is inside the polygon!");
    return false;
  }
  points = points.concat([points[0]]);
  v_r = points[0];
  v_l = points[0];
  for (i = j = 1, ref = points.length - 2; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
    e_prev = orientation_test(points[i - 1], points[i], new_point) >= 0;
    e_next = orientation_test(points[i], points[i + 1], new_point) >= 0;
    if (!e_prev && e_next) {
      v_r = points[i];
    } else if (e_prev && !e_next) {
      v_l = points[i];
    }
  }
  return [true, v_l, v_r];
};

find_intersecting_edge = function(input_points, new_point) {
  var list, middle, o1, o2, start, stop;
  list = input_points.slice(0);
  if (inclusion_in_hull(list, new_point)) {
    console.log("The point ", new_point, "is inside the polygon!");
    return false;
  }
  list = list.concat([list[0]]);
  start = 0;
  stop = list.length - 1;
  middle = Math.floor((start + stop) / 2);
  while (start < stop) {
    o1 = orientation_test(new_point, list[0], list[middle]);
    o2 = orientation_test(new_point, list[0], list[middle + 1]);
    if (new_point.x <= list[0].x) {
      if (o1 <= 0 && o2 >= 0) {
        return [middle, list[middle], list[middle + 1]];
      } else if (o1 >= 0 && o2 >= 0) {
        stop = middle;
      } else {
        start = middle + 1;
      }
    } else {
      if (o1 >= 0 && o2 <= 0) {
        return [middle, list[middle], list[middle + 1]];
      } else if (o1 >= 0 && o2 >= 0) {
        start = middle + 1;
      } else {
        stop = middle;
      }
    }
    middle = Math.floor((start + stop) / 2);
  }
  if (new_point.y < points[0].y) {
    return [list.length - 2, list[points.length - 2], list[0]];
  } else {
    return [0, list[0], list[1]];
  }
};

find_tangents_bin_search = function(input_points, new_point) {
  var intersecting_edge, middle, middle_bottom, middle_top, o_bottom_1, o_bottom_2, o_top_1, o_top_2, points, start, start_top, stop, stop_bottom, v_b, v_t;
  points = input_points.slice(0);
  if (inclusion_in_hull(points, new_point)) {
    console.log("The point ", new_point, "is inside the polygon!");
    return false;
  }
  intersecting_edge = find_intersecting_edge(points, new_point);
  stop_bottom = intersecting_edge[0];
  start_top = stop_bottom + 1;
  if (stop_bottom === 1) {
    stop_bottom = 2;
  }
  points = points.concat([points[0]]);
  start = 0;
  stop = points.length - 1;
  middle = Math.floor((start + stop) / 2);
  middle_bottom = Math.floor((start + stop_bottom) / 2);
  middle_top = Math.floor((start_top + stop) / 2);
  v_b = false;
  v_t = false;
  while (start < stop_bottom) {
    o_bottom_1 = orientation_test(new_point, points[middle_bottom - 1], points[middle_bottom]);
    o_bottom_2 = orientation_test(new_point, points[middle_bottom], points[middle_bottom + 1]);
    if (o_bottom_1 * o_bottom_2 <= 0) {
      v_b = new Point(points[middle_bottom].x, points[middle_bottom].y);
      break;
    } else if (o_bottom_1 <= 0 && o_bottom_2 <= 0) {
      if (new_point.x < points[0].x) {
        start = middle_bottom + 1;
      } else {
        stop_bottom = middle_bottom;
      }
    } else if (o_bottom_1 >= 0 && o_bottom_2 >= 0) {
      if (new_point.x < points[0].x) {
        stop_bottom = middle_bottom;
      } else {
        start = middle_bottom + 1;
      }
    }
    middle_bottom = Math.floor((start + stop_bottom) / 2);
  }
  while (start_top < stop) {
    o_top_1 = orientation_test(new_point, points[middle_top - 1], points[middle_top]);
    o_top_2 = orientation_test(new_point, points[middle_top], points[middle_top + 1]);
    if (o_top_1 * o_top_2 <= 0) {
      v_t = new Point(points[middle_top].x, points[middle_top].y);
      break;
    } else if (o_top_1 >= 0 && o_top_2 >= 0) {
      if (new_point.x < points[0].x) {
        start_top = middle_top + 1;
      } else {
        stop = middle_top;
      }
    } else if (o_top_1 <= 0 && o_top_2 <= 0) {
      if (new_point.x < points[0].x) {
        stop = middle_top;
      } else {
        start_top = middle_top + 1;
      }
    }
    middle_top = Math.floor((start_top + stop) / 2);
  }
  v_b = points[middle_bottom];
  v_t = points[middle_top];
  return [true, v_b, v_t];
};

points = [new Point(-1, 3), new Point(-1, -2), new Point(2, -2), new Point(2, 1), new Point(-2, 1), new Point(4, -2)];

new_point = new Point(-4, 0);

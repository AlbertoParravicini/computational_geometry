// Generated by CoffeeScript 1.11.1
var Point, PointColor, area_of_triangle, check_if_vertex_makes_ear, check_self_intersection_new_point, create_adj_list, key_point, orientation_test, place_guards, point_inside_triangle, simple_polygon_orientation_clockwise, squared_distance, swap, triangle_decomposition, triangle_decomposition_recursive, tricolor_triangulation,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Point = (function() {
  Point.prototype.x = 0.0;

  Point.prototype.y = 0.0;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  return Point;

})();

PointColor = (function() {
  function PointColor(x, y) {
    this.x = x;
    this.y = y;
    this.color = 0;
  }

  PointColor.prototype.toString = function() {
    return "x: " + this.x + " - y: " + this.y + " - color: " + this.color + "\n";
  };

  return PointColor;

})();

key_point = function(point) {
  return point.x.toString() + ", " + point.y.toString();
};

swap = function(list, index_1, index_2) {
  var temp;
  temp = list[index_1];
  list[index_1] = list[index_2];
  return list[index_2] = temp;
};

squared_distance = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

area_of_triangle = function(a, b, c, abs, divide) {
  var res;
  if (abs == null) {
    abs = true;
  }
  if (divide == null) {
    divide = true;
  }
  res = (a.x * b.y) + (a.y * c.x) + (b.x * c.y) - (b.y * c.x) - (c.y * a.x) - (b.x * a.y);
  if (divide === true) {
    res = (1 / 2) * res;
  }
  if (abs === true) {
    res = Math.abs(res);
  }
  return res;
};

orientation_test = function(p, q, r) {
  var determinant;
  determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
  return determinant;
};

point_inside_triangle = function(a, b, c, p) {
  var abs, b1, b2, b3, divide;
  if (area_of_triangle(a, b, c, divide = false, abs = false) === 0) {
    return false;
  }
  b1 = orientation_test(a, b, p) > 0;
  b2 = orientation_test(b, c, p) > 0;
  b3 = orientation_test(c, a, p) > 0;
  return (b1 === b2) && (b2 === b3);
};

simple_polygon_orientation_clockwise = function(input_simple_polygon) {
  var area, i, k, ref;
  if (input_simple_polygon.length < 3) {
    throw new Error("the size of the input polygon is ", input_simple_polygon.length);
  }
  area = 0;
  for (i = k = 1, ref = input_simple_polygon.length; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
    area += (input_simple_polygon[modulo(i, input_simple_polygon.length)].x - input_simple_polygon[i - 1].x) * (input_simple_polygon[modulo(i, input_simple_polygon.length)].y + input_simple_polygon[i - 1].y);
  }
  if (area > 0) {
    return true;
  } else {
    return false;
  }
};

check_self_intersection_new_point = function(input_points_list, new_point) {
  var i, k, o1, o2, o3, o4, points, ref;
  if (input_points_list.length < 2) {
    return false;
  }
  if (input_points_list.length === 2 && orientation_test(input_points_list[0], input_points_list[1], new_point) !== 0) {
    return false;
  }
  points = input_points_list.slice();
  for (i = k = 1, ref = points.length - 2; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
    o1 = orientation_test(points[i - 1], points[i], points[points.length - 1]);
    o2 = orientation_test(points[i - 1], points[i], new_point);
    o3 = orientation_test(points[points.length - 1], new_point, points[i - 1]);
    o4 = orientation_test(points[points.length - 1], new_point, points[i]);
    if (o1 * o2 < 0 && o3 * o4 < 0) {
      return true;
    }
  }
  return false;
};

check_if_vertex_makes_ear = function(input_polygon, vertex_index) {
  var a, b, c, i, k, ref;
  a = input_polygon[modulo(vertex_index - 1, input_polygon.length)];
  b = input_polygon[vertex_index];
  c = input_polygon[modulo(vertex_index + 1, input_polygon.length)];
  if (simple_polygon_orientation_clockwise(input_polygon)) {
    if (orientation_test(a, b, c) >= 0) {
      return false;
    }
  } else {
    if (orientation_test(a, b, c) <= 0) {
      return false;
    }
  }
  for (i = k = 0, ref = input_polygon.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    if ((i !== vertex_index) && (i !== modulo(vertex_index - 1, input_polygon.length)) && (i !== modulo(vertex_index + 1, input_polygon.length)) && point_inside_triangle(a, b, c, input_polygon[i])) {
      return false;
    }
  }
  return true;
};

triangle_decomposition = function(input_polygon) {
  var ear_found, i, polygon, triangles;
  polygon = input_polygon.slice();
  i = 0;
  triangles = [];
  while (polygon.length > 3) {
    ear_found = check_if_vertex_makes_ear(polygon, i);
    if (ear_found) {
      triangles.push([polygon[modulo(i - 1, polygon.length)], polygon[modulo(i + 1, polygon.length)], polygon[i]]);
      polygon.splice(i, 1);
      i = 0;
    } else {
      i++;
    }
  }
  triangles.push([polygon[modulo(-1, polygon.length)], polygon[modulo(1, polygon.length)], polygon[0]]);
  return triangles;
};

triangle_decomposition_recursive = function(input_polygon, triangles) {
  var ear_found, i, k, polygon, ref;
  polygon = input_polygon.slice();
  if (polygon.length <= 3) {
    triangles.push([polygon[modulo(-1, polygon.length)], polygon[modulo(1, polygon.length)], polygon[0]]);
    return triangles;
  } else {
    for (i = k = 0, ref = polygon.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      ear_found = check_if_vertex_makes_ear(polygon, i);
      if (ear_found) {
        triangles.push([polygon[modulo(i - 1, polygon.length)], polygon[modulo(i + 1, polygon.length)], polygon[i]]);
        polygon.splice(i, 1);
        return triangle_decomposition_recursive(polygon, triangles);
      }
    }
  }
};

create_adj_list = function(triangulation) {
  var dictionary, i, j, k, l, len, m, ref, triangle;
  dictionary = {};
  for (k = 0, len = triangulation.length; k < len; k++) {
    triangle = triangulation[k];
    for (i = l = 0; l <= 2; i = ++l) {
      for (j = m = 0; m <= 2; j = ++m) {
        if (i !== j) {
          if (dictionary[key_point(triangle[i])] === void 0) {
            dictionary[key_point(triangle[i])] = [triangle[j]];
          } else {
            if (ref = triangle[j], indexOf.call(dictionary[key_point(triangle[i])], ref) < 0) {
              dictionary[key_point(triangle[i])].push(triangle[j]);
            }
          }
        }
      }
    }
  }
  return dictionary;
};

tricolor_triangulation = function(adj_list) {
  var color, index, k, l, len, len1, len2, m, n, n_1, neighbours, p, ref, ref1;
  ref = Object.keys(adj_list);
  for (k = 0, len = ref.length; k < len; k++) {
    p = ref[k];
    color = [1, 2, 3];
    neighbours = adj_list[p];
    for (l = 0, len1 = neighbours.length; l < len1; l++) {
      n = neighbours[l];
      index = color.indexOf(n.color);
      if (index >= 0) {
        color.splice(index, 1);
      }
    }
    n_1 = neighbours[0];
    ref1 = adj_list[key_point(n_1)];
    for (m = 0, len2 = ref1.length; m < len2; m++) {
      n = ref1[m];
      if (key_point(n) === p) {
        n.color = color[0];
      }
    }
  }
  return adj_list;
};

place_guards = function(input_colored_points) {
  var count, guards_location, i, k, l, len, len1, m, min_count, min_count_index, p;
  count = [0, 0, 0];
  for (k = 0, len = input_colored_points.length; k < len; k++) {
    p = input_colored_points[k];
    count[p.color - 1] += 1;
  }
  min_count = 100000;
  min_count_index = -1;
  for (i = l = 0; l <= 2; i = ++l) {
    if (count[i] < min_count) {
      min_count = count[i];
      min_count_index = i;
    }
  }
  guards_location = [];
  for (m = 0, len1 = input_colored_points.length; m < len1; m++) {
    p = input_colored_points[m];
    if (p.color === min_count_index + 1) {
      guards_location.push(p);
    }
  }
  return guards_location;
};

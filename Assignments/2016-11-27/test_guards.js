// Generated by CoffeeScript 1.11.1
var draw, draw_triangle, drawing_polygon_done, guards, h, input_points, keyPressed, mousePressed, query_point, r1, r2, r3, result, setup, triangles, w,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

input_points = [];

drawing_polygon_done = false;

query_point = false;

result = false;

triangles = false;

guards = [];

w = 1200;

h = 800;

r1 = Math.random();

r2 = Math.random();

r3 = Math.random();

setup = function() {
  createCanvas(w, h);
  return fill('black');
};

draw = function() {
  var i, j, k, l, len, len1, len2, m, n, p, p_i, ref, ref1;
  background(230);
  line(0, h / 2, w, h / 2);
  line(w / 2, 0, w / 2, h);
  fill("black");
  stroke("black");
  for (j = 0, len = input_points.length; j < len; j++) {
    p_i = input_points[j];
    ellipse(p_i.x, p_i.y, 4, 4);
  }
  if (!triangles) {
    if (input_points.length >= 2) {
      for (i = k = 0, ref = input_points.length - 2; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        line(input_points[i].x, input_points[i].y, input_points[i + 1].x, input_points[i + 1].y);
      }
    }
    if (drawing_polygon_done) {
      line(input_points[0].x, input_points[0].y, input_points[input_points.length - 1].x, input_points[input_points.length - 1].y);
    }
  }
  if (triangles) {
    for (i = l = 0, ref1 = triangles.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
      draw_triangle(triangles[i]);
    }
    for (m = 0, len1 = input_points.length; m < len1; m++) {
      p = input_points[m];
      if (p.color === 1) {
        fill(255, 51, 51);
        stroke(255, 51, 51);
      } else if (p.color === 2) {
        fill(0, 102, 255);
        stroke(0, 102, 255);
      } else if (p.color === 3) {
        fill(51, 204, 51);
        stroke(51, 204, 51);
      } else {
        fill("brown");
        stroke("brown");
      }
      ellipse(p.x, p.y, 6, 6);
    }
    for (n = 0, len2 = guards.length; n < len2; n++) {
      p = guards[n];
      fill(255, 212, 73);
      stroke(255, 212, 73);
      ellipse(p.x, p.y, 14, 14);
    }
    fill("black");
    return stroke("black");
  }
};

mousePressed = function() {
  var adj_list, close_enough, new_point;
  if (!drawing_polygon_done) {
    new_point = new PointColor(mouseX, mouseY);
    if (input_points.length > 2) {
      close_enough = Math.pow(new_point.x - input_points[0].x, 2) + Math.pow(new_point.y - input_points[0].y, 2) <= h / 2;
      if (close_enough) {
        if (check_self_intersection_new_point(input_points, input_points[0])) {
          return console.log(new_point, "creates a self-intersection!");
        } else {
          drawing_polygon_done = true;
          triangles = triangle_decomposition(input_points);
          adj_list = create_adj_list(triangles);
          tricolor_triangulation(adj_list);
          guards = place_guards(input_points);
          return console.log("dec:", triangles);
        }
      } else {
        if (check_self_intersection_new_point(input_points, new_point)) {
          return console.log(new_point, "creates a self-intersection!");
        } else {
          return input_points.push(new_point);
        }
      }
    } else {
      return input_points.push(new_point);
    }
  }
};

keyPressed = function() {
  var adj_list, direction;
  if (input_points.length > 2 && !drawing_polygon_done) {
    if (check_self_intersection_new_point(input_points, input_points[0])) {
      console.log("Closing the polygon creates a self-intersection!");
    } else {
      drawing_polygon_done = true;
      direction = simple_polygon_orientation_clockwise(input_points) ? "counter-clockwise" : "clockwise";
      console.log("direction: ", direction, "\n");
    }
  }
  if (drawing_polygon_done) {
    triangles = triangle_decomposition(input_points);
    adj_list = create_adj_list(triangles);
    tricolor_triangulation(adj_list);
    guards = place_guards(input_points);
    console.log("dec:", triangles);
    return console.log("points:", input_points);
  }
};

draw_triangle = function(points) {
  var coord, j, len, p_i;
  coord = points[0].x + points[1].x + points[2].x + points[0].y + points[1].y + points[2].y;
  fill(modulo(coord * r1, 256), modulo(coord * r2, 256), modulo(coord * r3, 256), 40);
  beginShape();
  for (j = 0, len = points.length; j < len; j++) {
    p_i = points[j];
    vertex(p_i.x, p_i.y);
  }
  return endShape(CLOSE);
};

// Generated by CoffeeScript 1.11.1
var BinarySearchTree, Edge, Node, Point, PointEdge, PointIntersection, area_of_triangle, check_intersection, check_list, compare_y, edges_points, i, j, len, orientation_test, p1, p2, points, squared_distance, swap, sweep_line_intersection, temp_edge, tree;

Point = (function() {
  Point.prototype.x = 0.0;

  Point.prototype.y = 0.0;

  function Point(x1, y1) {
    this.x = x1;
    this.y = y1;
  }

  Point.prototype.toString = function() {
    return "x: " + this.x + " - y: " + this.y;
  };

  return Point;

})();

PointEdge = (function() {
  function PointEdge(x1, y1, edge) {
    this.x = x1;
    this.y = y1;
    this.edge = edge;
    this.start = false;
    this.edge = null;
  }

  PointEdge.prototype.toString = function() {
    return "x: " + this.x + " - y: " + this.y + " - start: " + this.start + "\n";
  };

  return PointEdge;

})();

PointIntersection = (function() {
  function PointIntersection(x1, y1, edge_11, edge_21) {
    this.x = x1;
    this.y = y1;
    this.edge_1 = edge_11;
    this.edge_2 = edge_21;
  }

  PointIntersection.prototype.toString = function() {
    return "x: " + this.x + " - y: " + this.y + " - edge_1: " + this.edge_1 + " - edge_1: " + this.edge_2 + "\n";
  };

  return PointIntersection;

})();

Edge = (function() {
  function Edge(input_p1, input_p2) {
    this.start_point = null;
    this.end_point = null;
    if (input_p1 !== null && input_p2 !== null) {
      if (input_p1.x < input_p2.x) {
        this.start_point = input_p1;
        this.start_point.start = true;
        this.end_point = input_p2;
      } else {
        this.start_point = input_p2;
        this.start_point.start = true;
        this.end_point = input_p1;
      }
      this.start_point.edge = this;
      this.end_point.edge = this;
    }
  }

  Edge.prototype.toString = function() {
    return "start " + this.start_point.toString() + " - end: " + this.end_point.toString() + "\n";
  };

  return Edge;

})();

swap = function(list, index_1, index_2) {
  var temp;
  temp = list[index_1];
  list[index_1] = list[index_2];
  return list[index_2] = temp;
};

squared_distance = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

area_of_triangle = function(a, b, c, abs, divide) {
  var res;
  if (abs == null) {
    abs = true;
  }
  if (divide == null) {
    divide = true;
  }
  res = (a.x * b.y) + (a.y * c.x) + (b.x * c.y) - (b.y * c.x) - (c.y * a.x) - (b.x * a.y);
  if (divide === true) {
    res = (1 / 2) * res;
  }
  if (abs === true) {
    res = Math.abs(res);
  }
  return res;
};

Node = (function() {
  function Node(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.parent = null;
  }

  return Node;

})();

BinarySearchTree = (function() {
  function BinarySearchTree(compare_function) {
    this.root = null;
    this.compare = !compare_function ? function(a, b) {
      if (a > b) {
        return 1;
      } else if (a < b) {
        return -1;
      } else {
        return 0;
      }
    } : compare_function;
  }

  BinarySearchTree.prototype.insert = function(value) {
    var current, node, results;
    node = new Node(value);
    current = null;
    if (this.root === null) {
      return this.root = node;
    } else {
      current = this.root;
      results = [];
      while (true) {
        if (this.compare(value, current.value) < 0) {
          if (current.left === null) {
            current.left = node;
            node.parent = current;
            break;
          } else {
            results.push(current = current.left);
          }
        } else if (this.compare(value, current.value) > 0) {
          if (current.right === null) {
            current.right = node;
            node.parent = current;
            break;
          } else {
            results.push(current = current.right);
          }
        } else {
          break;
        }
      }
      return results;
    }
  };

  BinarySearchTree.prototype.search = function(value) {
    var current, found;
    found = false;
    current = this.root;
    while (!found && current) {
      if (this.compare(value, current.value) < 0) {
        current = current.left;
      } else if (this.compare(value, current.value) > 0) {
        current = current.right;
      } else {
        found = true;
      }
    }
    return found;
  };

  BinarySearchTree.prototype.remove = function(value) {
    var child_count, current, found, parent, replacement, replacement_parent;
    found = false;
    parent = null;
    current = this.root;
    child_count = 0;
    replacement = null;
    replacement_parent = null;
    while (!found && current) {
      if (this.compare(value, current.value) < 0) {
        parent = current;
        current = current.left;
      } else if (this.compare(value, current.value) > 0) {
        parent = current;
        current = current.right;
      } else {
        found = true;
      }
    }
    if (found) {
      child_count = (current.left !== null ? 1 : 0) + (current.right !== null ? 1 : 0);
      if (current === this.root) {
        if (child_count === 0) {
          return this.root = null;
        } else if (child_count === 1) {
          return this.root = current.right === null ? current.left : current.right;
        } else {
          replacement = this.root.left;
          while (replacement.right !== null) {
            replacement_parent = replacement;
            replacement = replacement.right;
          }
          if (replacement_parent !== null) {
            replacement_parent.right = replacement.left;
            replacement.right = this.root.right;
            replacement.left = this.root.left;
            replacement.left.parent = this.left;
          } else {
            replacement.right = this.root.right;
            replacement.right.parent = this.root;
          }
          return this.root = replacement;
        }
      } else {
        if (child_count === 0) {
          if (this.compare(value, parent.value) < 0) {
            parent.left = null;
          } else {
            parent.right = null;
          }
        }
        if (child_count === 1) {
          if (this.compare(value, parent.value) < 0) {
            parent.left = current.left === null ? current.right : current.left;
            parent.left.parent = parent;
          } else {
            parent.right = current.left === null ? current.right : current.left;
            parent.right.parent = parent;
          }
        }
        if (child_count === 2) {
          replacement = current.left;
          replacement_parent = current;
          while (replacement.right !== null) {
            replacement_parent = replacement;
            replacement = replacement.right;
          }
          replacement_parent.right = replacement.left;
          replacement.right = current.right;
          replacement.left = current.left;
          if (this.compare(current.value, parent.value) < 0) {
            parent.left = replacement;
            return replacement.parent = parent;
          } else {
            parent.right = replacement;
            return replacement.parent = parent;
          }
        }
      }
    }
  };

  BinarySearchTree.prototype.predecessor = function(value, root, pred) {
    var current;
    if (root !== null && root !== void 0) {
      if (root.value === value) {
        if (root.left !== null) {
          current = root.left;
          while (current.right !== null) {
            current = current.right;
          }
          pred = current.value;
        }
        return pred;
      } else if (this.compare(value, root.value) < 0) {
        return this.predecessor(value, root.left, pred);
      } else {
        pred = root.value;
        return this.predecessor(value, root.right, pred);
      }
    } else {
      return pred;
    }
  };

  BinarySearchTree.prototype.successor = function(value, root, succ) {
    var current;
    if (root !== null && root !== void 0) {
      if (root.value === value) {
        if (root.right !== null) {
          current = root.right;
          while (current.left !== null) {
            current = current.left;
          }
          succ = current.value;
        }
        return succ;
      } else if (this.compare(value, root.value) < 0) {
        succ = root.value;
        return this.successor(value, root.left, succ);
      } else {
        return this.successor(value, root.right, succ);
      }
    } else {
      return succ;
    }
  };

  BinarySearchTree.prototype.traverse = function(process) {
    var in_order;
    in_order = function(node) {
      if (node) {
        if (node.left !== null) {
          in_order(node.left);
        }
        process.call(this, node);
        if (node.right !== null) {
          return in_order(node.right);
        }
      }
    };
    return in_order(this.root);
  };

  BinarySearchTree.prototype.size = function() {
    var length;
    length = 0;
    this.traverse(function(node) {
      return length++;
    });
    return length;
  };

  BinarySearchTree.prototype.to_array = function() {
    var result;
    result = [];
    this.traverse(function(node) {
      return result.push(node.value);
    });
    return result;
  };

  BinarySearchTree.prototype.toString = function() {
    return this.to_array().toString();
  };

  return BinarySearchTree;

})();

points = [1, 3, 8, 10, 15, 34, 6, 9, 2];

compare_y = function(a, b) {
  if (a.y > b.y) {
    return 1;
  } else if (a.y < b.y) {
    return -1;
  } else {
    return 0;
  }
};

tree = new BinarySearchTree();

for (j = 0, len = points.length; j < len; j++) {
  i = points[j];
  tree.insert(i);
}

console.log(tree.size());

console.log(tree.predecessor(11, tree.root));

console.log(tree.predecessor(1, tree.root));

points = [new Point(2, 5), new Point(10, 7), new Point(3, 4), new Point(8, 5), new Point(6, 3), new Point(4, 8), new Point(11, 4), new Point(5, 1), new Point(9, 10), new Point(12, 9), new Point(7.1, 1), new Point(7.3, 7)];

i = 0;

edges_points = [];

while (i < points.length) {
  p1 = new PointEdge(points[i].x, points[i].y);
  p2 = new PointEdge(points[i + 1].x, points[i + 1].y);
  temp_edge = new Edge(p1, p2);
  edges_points.push(p1, p2);
  i += 2;
}

orientation_test = function(p, q, r) {
  var determinant;
  determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
  return determinant;
};

check_intersection = function(edge_1, edge_2) {
  var m1, m2, o1, o2, o3, o4, q1, q2, x, y;
  if (edge_1 === null || edge_1 === void 0 || edge_2 === null || edge_2 === void 0) {
    return false;
  }
  o1 = orientation_test(edge_1.start_point, edge_1.end_point, edge_2.start_point);
  o2 = orientation_test(edge_1.start_point, edge_1.end_point, edge_2.end_point);
  o3 = orientation_test(edge_2.start_point, edge_2.end_point, edge_1.start_point);
  o4 = orientation_test(edge_2.start_point, edge_2.end_point, edge_1.end_point);
  if (o1 * o2 < 0 && o3 * o4 < 0) {
    m1 = (edge_1.end_point.y - edge_1.start_point.y) / (edge_1.end_point.x - edge_1.start_point.x);
    m2 = (edge_2.end_point.y - edge_2.start_point.y) / (edge_2.end_point.x - edge_2.start_point.x);
    q1 = (edge_1.start_point.y * edge_1.end_point.x - edge_1.end_point.y * edge_1.start_point.x) / (edge_1.end_point.x - edge_1.start_point.x);
    q2 = (edge_2.start_point.y * edge_2.end_point.x - edge_2.end_point.y * edge_2.start_point.x) / (edge_2.end_point.x - edge_2.start_point.x);
    x = (q2 - q1) / (m1 - m2);
    y = (m1 * q2 - m2 * q1) / (m1 - m2);
    if (edge_2.end_point.y > edge_1.end_point.y) {
      return new PointIntersection(x, y, edge_2, edge_1);
    } else {
      return new PointIntersection(x, y, edge_1, edge_2);
    }
  }
  return false;
};

check_list = function(list, point) {
  var k, len1, p;
  for (k = 0, len1 = list.length; k < len1; k++) {
    p = list[k];
    if (p.x === point.x && p.y === point.y) {
      return true;
    }
  }
  return false;
};

sweep_line_intersection = function(input_edges) {
  var edge_1, edge_2, intersection, intersections, num_of_intersections, point, pred, seg_a, seg_b, succ, sweep_line;
  points = input_edges.slice();
  intersections = [];
  points.sort(function(a, b) {
    if (a.x > b.x) {
      return 1;
    } else if (a.x < b.x) {
      return -1;
    } else {
      return 0;
    }
  });
  compare_y = function(a, b) {
    if (a.y > b.y) {
      return 1;
    } else if (a.y < b.y) {
      return -1;
    } else {
      return 0;
    }
  };
  sweep_line = new BinarySearchTree(compare_y);
  num_of_intersections = 0;
  while (points.length > 0) {
    point = points[0];
    console.log(points.length);
    if (point instanceof PointEdge && point.start) {
      sweep_line.insert(point);
      pred = sweep_line.predecessor(point, sweep_line.root);
      succ = sweep_line.successor(point, sweep_line.root);
      if (pred !== null && pred !== void 0) {
        intersection = check_intersection(point.edge, pred.edge);
        if (intersection) {
          points.push(intersection);
          points.sort(function(a, b) {
            if (a.x > b.x) {
              return 1;
            } else if (a.x < b.x) {
              return -1;
            } else {
              return 0;
            }
          });
        }
      }
      if (succ !== null && succ !== void 0) {
        intersection = check_intersection(point.edge, succ.edge);
        if (intersection) {
          points.push(intersection);
          points.sort(function(a, b) {
            if (a.x > b.x) {
              return 1;
            } else if (a.x < b.x) {
              return -1;
            } else {
              return 0;
            }
          });
        }
      }
    } else if (point instanceof PointEdge && !point.start) {
      pred = sweep_line.predecessor(point, sweep_line.root);
      succ = sweep_line.successor(point, sweep_line.root);
      sweep_line.remove(point.edge.start_point);
      sweep_line.remove(point.edge.end_point);
      if (pred !== null && succ !== null && pred !== void 0 && succ !== void 0) {
        intersection = check_intersection(pred.edge, succ.edge);
        if (intersection) {
          if (!check_list(points, intersection)) {
            points.push(intersection);
            points.sort(function(a, b) {
              if (a.x > b.x) {
                return 1;
              } else if (a.x < b.x) {
                return -1;
              } else {
                return 0;
              }
            });
          }
        }
      }
    } else {
      intersections.push(point);
      edge_1 = point.edge_1;
      edge_2 = point.edge_2;
      console.log("CHECK: ", edge_1.end_point.y > edge_2.end_point.y);
      seg_a = sweep_line.successor(edge_2.end_point, sweep_line.root);
      seg_b = sweep_line.predecessor(edge_1.end_point, sweep_line.root);
      if (seg_a !== null && seg_a !== void 0) {
        intersection = check_intersection(edge_2, seg_a.edge);
        if (intersection) {
          if (!check_list(points, intersection)) {
            points.push(intersection);
            points.sort(function(a, b) {
              if (a.x > b.x) {
                return 1;
              } else if (a.x < b.x) {
                return -1;
              } else {
                return 0;
              }
            });
          }
        }
      }
      if (seg_b !== null && seg_b !== void 0) {
        intersection = check_intersection(edge_1, seg_b.edge);
        if (intersection) {
          if (!check_list(points, intersection)) {
            points.push(intersection);
            points.sort(function(a, b) {
              if (a.x > b.x) {
                return 1;
              } else if (a.x < b.x) {
                return -1;
              } else {
                return 0;
              }
            });
          }
        }
      }
    }
    points.splice(0, 1);
  }
  return intersections;
};

console.log(edges_points);

console.log("\nINT:", sweep_line_intersection(edges_points));

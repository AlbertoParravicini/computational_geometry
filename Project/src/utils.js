// Generated by CoffeeScript 1.12.3
var KSetElem, Point, check_horizontal_intersection, check_inclusion_in_polygon, orientation_test, radial_sort, squared_distance, swap,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

Point = (function() {
  Point.prototype.x = 0.0;

  Point.prototype.y = 0.0;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.prototype.toString = function() {
    return "Point(" + this.x + ", " + this.y + ")\n";
  };

  return Point;

})();

KSetElem = (function(superClass) {
  extend(KSetElem, superClass);

  function KSetElem(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
    KSetElem.__super__.constructor.call(this, this.x, this.y);
  }

  KSetElem.prototype.toString = function() {
    return "KSetElem(" + this.x + ", " + this.y + ", -- weight: " + this.weight(+")\n");
  };

  return KSetElem;

})(Point);

swap = function(list, index_1, index_2) {
  var temp;
  temp = list[index_1];
  list[index_1] = list[index_2];
  return list[index_2] = temp;
};

squared_distance = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

orientation_test = function(p, q, r) {
  var determinant;
  determinant = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
  return determinant;
};

radial_sort = function(points, arg) {
  var anchor, cw, ref;
  ref = arg != null ? arg : {}, anchor = ref.anchor, cw = ref.cw;
  if (points.length === 0) {
    return [];
  }
  if (anchor == null) {
    anchor = new Point(points[0].x, points[0].y);
  }
  if (cw == null) {
    cw = true;
  }
  points.sort(function(a, b) {
    var orientation;
    if (a.x - anchor.x === 0 && a.y - anchor.y === 0 && b.x - anchor.x !== 0 && b.y - anchor.y !== 0) {
      return -1;
    }
    if (a.x - anchor.x !== 0 && a.y - anchor.y !== 0 && b.x - anchor.x === 0 && b.y - anchor.y === 0) {
      return 1;
    }
    if (a.x - anchor.x >= 0 && b.x - anchor.x < 0) {
      return -1;
    }
    if (a.x - anchor.x < 0 && b.x - anchor.x >= 0) {
      return 1;
    }
    if (a.x - anchor.x === 0 && b.x - anchor.x === 0) {
      if (a.y - anchor.y < 0 && b.y - anchor.y < 0) {
        if (a.y < b.y) {
          return 1;
        } else {
          return -1;
        }
      } else {
        if (a.y > b.y) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    orientation = orientation_test(anchor, a, b);
    if (orientation === 0) {
      if (squared_distance(anchor, a) >= squared_distance(anchor, b)) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if (orientation > 0) {
        return 1;
      } else {
        return -1;
      }
    }
  });
  if (!cw) {
    points.reverse();
  }
  return points;
};

check_horizontal_intersection = function(p_1, p_2, query_point) {
  var a, b, ref;
  ref = p_1.y < p_2.y ? [p_1, p_2] : [p_2, p_1], a = ref[0], b = ref[1];
  if (query_point.y === a.y || query_point.y === a.y) {
    query_point.y += Number.MIN_VALUE;
  }
  if ((a.y - query_point.y) * (b.y - query_point.y) < 0 && orientation_test(a, b, query_point) < 0) {
    return true;
  } else {
    return false;
  }
};

check_inclusion_in_polygon = function(input_simple_polygon, query_point) {
  var i, intersection_count, j, p_1, p_2, points, ref;
  if (input_simple_polygon.length < 3) {
    throw new Error("the size of the input polygon is ", input_simple_polygon.length);
  }
  points = input_simple_polygon.slice();
  intersection_count = 0;
  for (i = j = 1, ref = points.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
    p_1 = points[i - 1];
    p_2 = points[modulo(i, points.length)];
    if (check_horizontal_intersection(p_1, p_2, query_point)) {
      intersection_count += 1;
    }
  }
  return modulo(intersection_count, 2) !== 0;
};

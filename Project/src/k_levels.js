// Generated by CoffeeScript 1.12.3
var compute_k_level, compute_reflex_vertices, compute_zonoid_vertices_from_reflex, h, w;

w = 1200;

h = 480;

compute_k_level = function(input_lines, k) {
  var best_so_far, current_line, first_intersection, i, intersections, j, k_level_points, l, l_i, len, lines, ref, x_i, y_i;
  console.log(input_lines);
  lines = input_lines.slice();
  k_level_points = [];
  lines.sort(function(a, b) {
    if (a.q > b.q) {
      return 1;
    } else if (a.q < b.q) {
      return -1;
    } else {
      return 0;
    }
  });
  console.log("\n\nSORTED:\n" + lines);
  current_line = lines[k - 1];
  k_level_points.push(new Point(0, current_line.q));
  while (true) {
    intersections = [];
    for (j = 0, len = lines.length; j < len; j++) {
      l_i = lines[j];
      if (current_line.m === l_i.m) {
        intersections.push(new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));
      } else {
        x_i = (l_i.q - current_line.q) / (current_line.m - l_i.m);
        y_i = l_i.m * x_i + l_i.q;
        intersections.push(new Point(x_i, y_i));
      }
    }
    first_intersection = -1;
    best_so_far = Number.POSITIVE_INFINITY;
    for (i = l = 0, ref = intersections.length - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
      if (intersections[i].x > k_level_points[k_level_points.length - 1].x) {
        if (intersections[i].x < best_so_far) {
          first_intersection = i;
          best_so_far = intersections[i].x;
        }
      }
    }
    if (first_intersection === -1) {
      k_level_points.push(new Point(10000, current_line.m * 10000 + current_line.q));
      break;
    }
    k_level_points.push(intersections[first_intersection]);
    current_line = lines[first_intersection];
  }
  return k_level_points;
};

compute_reflex_vertices = function(k_level) {
  var i, j, ref, reflex_vertices, res;
  reflex_vertices = [];
  for (i = j = 1, ref = k_level.length - 2; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
    res = orientation_test(k_level[i - 1], k_level[i], k_level[i + 1]);
    if (res > 0) {
      reflex_vertices.push(k_level[i]);
    }
  }
  return reflex_vertices;
};

compute_zonoid_vertices_from_reflex = function(reflex_vertices, lines) {
  var intersections, j, l, l_i, len, len1, len2, m, p_i, r_i, vertical_intersection, zonoid_vertex, zonoid_vertices;
  zonoid_vertices = [];
  for (j = 0, len = reflex_vertices.length; j < len; j++) {
    r_i = reflex_vertices[j];
    intersections = [];
    for (l = 0, len1 = lines.length; l < len1; l++) {
      l_i = lines[l];
      vertical_intersection = l_i.m * r_i.x + l_i.q;
      if (vertical_intersection < r_i.y) {
        intersections.push(new Point(r_i.x, vertical_intersection));
      }
    }
    zonoid_vertex = new Point(0, 0);
    for (m = 0, len2 = intersections.length; m < len2; m++) {
      p_i = intersections[m];
      zonoid_vertex.x += p_i.x;
      zonoid_vertex.y += p_i.y;
    }
    zonoid_vertex.x /= intersections.length;
    zonoid_vertex.y /= intersections.length;
    zonoid_vertices.push(zonoid_vertex);
  }
  return zonoid_vertices;
};

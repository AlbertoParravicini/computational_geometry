// Generated by CoffeeScript 1.12.3
(function() {
  var k_level_1_demo, k_levels_1_p5;

  k_level_1_demo = function(p_o) {
    var canvas_bound_original, canvas_mouseWheel, default_color, draw_poly, dual_lines, dual_lines_temp, h, input_points, k, k_level_u, k_level_u_temp, label, num_input_points, reflex_vertices_u, reflex_vertices_u_temp, scale_factor, select_event, slider, w, zonoid, zonoid_lines, zonoid_vertices_u;
    input_points = [new Point(0.31, 3), new Point(0.1, 0.6), new Point(0.4, 1.2), new Point(-0.4, 4.2), new Point(-0.3, 5), new Point(0.9, 0.3), new Point(0.8, -0.6), new Point(-0.8, 6), new Point(0.05, 2)];
    default_color = [121, 204, 147, 200];
    num_input_points = 15;
    scale_factor = 80;
    w = 640;
    h = 480;
    canvas_bound_original = 5;
    dual_lines = [];
    dual_lines_temp = [];
    k = 1;
    k_level_u = [];
    reflex_vertices_u = [];
    zonoid_vertices_u = [];
    k_level_u_temp = [];
    reflex_vertices_u_temp = [];
    zonoid_lines = [];
    zonoid = [];
    slider = false;
    label = false;
    p_o.setup = function() {
      var canvas, j, len, p;
      canvas = p_o.createCanvas(w, h);
      p_o.fill('red');
      p_o.frameRate(6);
      canvas.mouseWheel(canvas_mouseWheel);
      for (j = 0, len = input_points.length; j < len; j++) {
        p = input_points[j];
        dual_lines.push(create_line_from_m_q(p.x, p.y));
      }
      dual_lines_temp = dual_lines.map(function(l) {
        return [new Point(l.start.x * scale_factor, l.start.y * scale_factor), new Point(l.end.x * scale_factor, l.end.y * scale_factor)];
      });
      slider = p_o.createSlider(1, input_points.length, k, 1);
      slider.changed(select_event);
      label = p_o.createElement('p', 'Value of K');
      label.html("<b>K:</b> " + k);
      k_level_u = compute_k_level(dual_lines, k, {
        reverse: true
      });
      reflex_vertices_u = compute_reflex_vertices(k_level_u, {
        up: false
      });
      zonoid_vertices_u = compute_zonoid_vertices_from_reflex(reflex_vertices_u, dual_lines, {
        up: false
      });
      k_level_u_temp = k_level_u.map(function(p) {
        return new Point(p.x * scale_factor, p.y * scale_factor);
      });
      return reflex_vertices_u_temp = reflex_vertices_u.map(function(p) {
        return new Point(p.x * scale_factor, p.y * scale_factor);
      });
    };
    p_o.draw = function() {
      var i, j, l, len, len1, m, n, p, ref, results;
      p_o.background(253, 253, 253);
      p_o.fill("black");
      p_o.stroke("black");
      for (j = 0, len = dual_lines_temp.length; j < len; j++) {
        l = dual_lines_temp[j];
        p_o.stroke(default_color);
        p_o.strokeWeight(2);
        p_o.line(l[0].x, l[0].y, l[1].x, l[1].y);
      }
      p_o.fill(143, 27, 10, 200);
      p_o.stroke(231, 120, 58, 200);
      for (i = m = 1, ref = k_level_u.length - 1; 1 <= ref ? m <= ref : m >= ref; i = 1 <= ref ? ++m : --m) {
        p_o.strokeWeight(6);
        p_o.line(k_level_u_temp[i - 1].x, k_level_u_temp[i - 1].y, k_level_u_temp[i].x, k_level_u_temp[i].y);
      }
      p_o.strokeWeight(1);
      results = [];
      for (n = 0, len1 = reflex_vertices_u_temp.length; n < len1; n++) {
        p = reflex_vertices_u_temp[n];
        p_o.fill(143, 27, 10, 200);
        p_o.stroke(231, 120, 58, 200);
        results.push(p_o.ellipse(p.x, p.y, 20, 20));
      }
      return results;
    };
    canvas_mouseWheel = function(event) {
      if (event.deltaY > 0) {
        k -= 1;
      } else if (event.deltaY < 0) {
        k += 1;
      }
      if (k < 1) {
        k = 1;
      }
      if (k > dual_lines.length) {
        k = dual_lines.length;
      }
      k_level_u = compute_k_level(dual_lines, k, {
        reverse: true
      });
      reflex_vertices_u = compute_reflex_vertices(k_level_u, {
        up: false
      });
      slider.value(k);
      label.html("<b>K:</b> " + k);
      k_level_u_temp = k_level_u.map(function(p) {
        return new Point(p.x * scale_factor, p.y * scale_factor);
      });
      return reflex_vertices_u_temp = reflex_vertices_u.map(function(p) {
        return new Point(p.x * scale_factor, p.y * scale_factor);
      });
    };
    select_event = function() {
      k = slider.value();
      label.html("<b>K:</b> " + k);
      k_level_u = compute_k_level(dual_lines, k, {
        reverse: true
      });
      reflex_vertices_u = compute_reflex_vertices(k_level_u, {
        up: false
      });
      k_level_u_temp = k_level_u.map(function(p) {
        return new Point(p.x * scale_factor, p.y * scale_factor);
      });
      return reflex_vertices_u_temp = reflex_vertices_u.map(function(p) {
        return new Point(p.x * scale_factor, p.y * scale_factor);
      });
    };
    return draw_poly = function(p_o, points, arg) {
      var fill_color, j, len, p_i, ref, stroke_color;
      ref = arg != null ? arg : {}, fill_color = ref.fill_color, stroke_color = ref.stroke_color;
      if (fill_color == null) {
        fill_color = default_color;
      }
      if (stroke_color == null) {
        stroke_color = default_color;
      }
      p_o.fill(fill_color[0], fill_color[1], fill_color[2], fill_color[3]);
      p_o.stroke(stroke_color[0], stroke_color[1], stroke_color[2], stroke_color[3]);
      p_o.beginShape();
      for (j = 0, len = points.length; j < len; j++) {
        p_i = points[j];
        p_o.vertex(p_i.x, p_i.y);
      }
      p_o.endShape(p_o.CLOSE);
      p_o.fill("black");
      return p_o.stroke("black");
    };
  };

  k_levels_1_p5 = new p5(k_level_1_demo, "demo-k-levels-1-canvas");

}).call(this);

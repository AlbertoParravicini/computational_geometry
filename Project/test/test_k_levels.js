// Generated by CoffeeScript 1.12.3
var default_color, draw, draw_poly, dual_lines, h, input_points, k, k_level, leftmost_point, mouseWheel, num_input_points, reflex_vertices, scale_factor, setup, w, zonoid_vertices;

input_points = [new Point(2, -2), new Point(-0.8, 4.2), new Point(1, 3), new Point(0.1, 0.6), new Point(0.4, 1.2), new Point(-0.2, 2.2), new Point(1.4, 0.3), new Point(-0.3, 4.8)];

default_color = [121, 204, 147, 200];

num_input_points = 15;

scale_factor = 100;

h = 480;

w = 1200;

dual_lines = [];

k = 5;

k_level = [];

reflex_vertices = [];

zonoid_vertices = [];

setup = function() {
  var j, len, p;
  createCanvas(w, h);
  fill('red');
  frameRate(10);
  for (j = 0, len = input_points.length; j < len; j++) {
    p = input_points[j];
    dual_lines.push(create_line_from_m_q(p.x, p.y * scale_factor));
  }
  k_level = compute_k_level(dual_lines, k);
  reflex_vertices = compute_reflex_vertices(k_level);
  zonoid_vertices = compute_zonoid_vertices_from_reflex(reflex_vertices, dual_lines);
  return console.log(k_level);
};

draw = function() {
  var i, j, l, len, len1, len2, len3, m, n, o, p, q, ref, ref1;
  background(255, 251, 234);
  fill("black");
  stroke("black");
  for (j = 0, len = dual_lines.length; j < len; j++) {
    l = dual_lines[j];
    stroke(default_color);
    strokeWeight(2);
    line(l.start.x, l.start.y, l.end.x, l.end.y);
  }
  fill(143, 27, 10, 200);
  stroke(231, 120, 58, 200);
  ref = k_level.slice(1, +(k_level.length - 1) + 1 || 9e9);
  for (m = 0, len1 = ref.length; m < len1; m++) {
    p = ref[m];
    ellipse(p.x, p.y, 20, 20);
  }
  for (i = n = 1, ref1 = k_level.length - 1; 1 <= ref1 ? n <= ref1 : n >= ref1; i = 1 <= ref1 ? ++n : --n) {
    strokeWeight(6);
    line(k_level[i - 1].x, k_level[i - 1].y, k_level[i].x, k_level[i].y);
  }
  strokeWeight(1);
  fill(98, 122, 161, 200);
  stroke(21, 32, 50, 200);
  for (o = 0, len2 = reflex_vertices.length; o < len2; o++) {
    p = reflex_vertices[o];
    ellipse(p.x, p.y, 20, 20);
  }
  fill(98, 122, 161, 200);
  stroke(21, 32, 50, 200);
  for (q = 0, len3 = zonoid_vertices.length; q < len3; q++) {
    p = zonoid_vertices[q];
    ellipse(p.x, p.y, 20, 20);
  }
  return draw_poly(radial_sort(zonoid_vertices, {
    anchor: leftmost_point(zonoid_vertices),
    cw: true
  }), {
    fill_color: [16, 74, 34, 100],
    stroke_color: [16, 74, 34, 255]
  });
};

mouseWheel = function(event) {
  if (event.delta > 0) {
    k -= 1;
  } else if (event.delta < 0) {
    k += 1;
  }
  if (k < 1) {
    k = 1;
  }
  if (k > dual_lines.length) {
    k = dual_lines.length;
  }
  k_level = compute_k_level(dual_lines, k);
  reflex_vertices = compute_reflex_vertices(k_level);
  zonoid_vertices = compute_zonoid_vertices_from_reflex(reflex_vertices, dual_lines);
  return console.log("K: ", k);
};

draw_poly = function(points, arg) {
  var fill_color, j, len, p_i, ref, stroke_color;
  ref = arg != null ? arg : {}, fill_color = ref.fill_color, stroke_color = ref.stroke_color;
  if (fill_color == null) {
    fill_color = default_color;
  }
  if (stroke_color == null) {
    stroke_color = default_color;
  }
  fill(fill_color[0], fill_color[1], fill_color[2], fill_color[3]);
  stroke(stroke_color[0], stroke_color[1], stroke_color[2], stroke_color[3]);
  beginShape();
  for (j = 0, len = points.length; j < len; j++) {
    p_i = points[j];
    vertex(p_i.x, p_i.y);
  }
  return endShape(CLOSE);
};

leftmost_point = function(S) {
  var j, leftmost_p, len, p, ref;
  leftmost_p = S[0];
  ref = S.slice(1, +(S.length - 1) + 1 || 9e9);
  for (j = 0, len = ref.length; j < len; j++) {
    p = ref[j];
    if (p.x < leftmost_p.x) {
      leftmost_p = p;
    }
  }
  return leftmost_p;
};

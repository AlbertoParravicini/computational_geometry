// Generated by CoffeeScript 1.12.3
var canvas_bound_original, default_color, draw, draw_poly, dual_lines, h, input_points, k, k_level_d, k_level_u, leftmost_point, mouseWheel, num_input_points, reflex_vertices_d, reflex_vertices_u, rightmost_point, scale_factor, setup, translate_p, w, zonoid, zonoid_lines, zonoid_vertices_d, zonoid_vertices_u;

input_points = [new Point(0.31, 3), new Point(0.1, 0.6), new Point(0.4, 1.2), new Point(-0.4, 4.2), new Point(-0.3, 5), new Point(0.9, 0.3), new Point(0.8, -0.6), new Point(-0.8, 6), new Point(0.05, 2)];

default_color = [121, 204, 147, 200];

num_input_points = 15;

scale_factor = 80;

w = 1400;

h = 600;

canvas_bound_original = 5;

dual_lines = [];

k = 2;

k_level_u = [];

reflex_vertices_u = [];

zonoid_vertices_u = [];

k_level_d = [];

reflex_vertices_d = [];

zonoid_vertices_d = [];

zonoid_lines = [];

zonoid = [];

setup = function() {
  var j, len, len1, m, p, p_i, zonoid_dual_vertices;
  createCanvas(w, h);
  fill('red');
  frameRate(10);
  console.log("K:", k);
  for (j = 0, len = input_points.length; j < len; j++) {
    p = input_points[j];
    dual_lines.push(create_line_from_m_q(p.x, p.y));
  }
  k_level_u = compute_k_level(dual_lines, k, {
    reverse: true
  });
  reflex_vertices_u = compute_reflex_vertices(k_level_u, {
    up: false
  });
  zonoid_vertices_u = compute_zonoid_vertices_from_reflex(reflex_vertices_u, dual_lines, {
    up: false
  });
  k_level_d = compute_k_level(dual_lines, dual_lines.length - k + 1, {
    reverse: true
  });
  reflex_vertices_d = compute_reflex_vertices(k_level_d, {
    up: true
  });
  zonoid_vertices_d = compute_zonoid_vertices_from_reflex(reflex_vertices_d, dual_lines, {
    up: true
  });
  zonoid_dual_vertices = zonoid_vertices_u.concat(zonoid_vertices_d);
  for (m = 0, len1 = zonoid_dual_vertices.length; m < len1; m++) {
    p_i = zonoid_dual_vertices[m];
    zonoid_lines.push(new Line(new Point(-10000, -p_i.x * -10000 + p_i.y), new Point(10000, -p_i.x * 10000 + p_i.y), -p_i.x, p_i.y));
  }
  zonoid = compute_zonoid(input_points, {
    k: k - 1
  });
  return console.log("K: ", k);
};

draw = function() {
  var i, i1, j, j1, k_level_d_temp, k_level_u_temp, l, l_i, len, len1, len2, len3, len4, len5, len6, len7, m, n, o, p, q, r, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, t, u, v, x, y, z, z_i, zonoid_slice_d, zonoid_slice_u, zonoid_temp, zonoid_vertices_d_temp, zonoid_vertices_u_temp;
  background(255, 251, 234);
  fill("black");
  stroke("black");
  ref = dual_lines.map(function(l) {
    return [new Point(l.start.x * scale_factor, l.start.y * scale_factor), new Point(l.end.x * scale_factor, l.end.y * scale_factor)];
  });
  for (j = 0, len = ref.length; j < len; j++) {
    l = ref[j];
    stroke(default_color);
    strokeWeight(2);
    line(l[0].x, l[0].y, l[1].x, l[1].y);
  }
  fill(143, 27, 10, 200);
  stroke(231, 120, 58, 200);
  k_level_u_temp = k_level_u.map(function(p) {
    return new Point(p.x * scale_factor, p.y * scale_factor);
  });
  for (i = m = 1, ref1 = k_level_u.length - 1; 1 <= ref1 ? m <= ref1 : m >= ref1; i = 1 <= ref1 ? ++m : --m) {
    strokeWeight(6);
    line(k_level_u_temp[i - 1].x, k_level_u_temp[i - 1].y, k_level_u_temp[i].x, k_level_u_temp[i].y);
  }
  strokeWeight(1);
  ref2 = reflex_vertices_u.map(function(p) {
    return new Point(p.x * scale_factor, p.y * scale_factor);
  });
  for (n = 0, len1 = ref2.length; n < len1; n++) {
    p = ref2[n];
    fill(143, 27, 10, 200);
    stroke(231, 120, 58, 200);
    ellipse(p.x, p.y, 20, 20);
    y = p.y + 15;
    fill(default_color);
    stroke(default_color);
    strokeWeight(2);
    while (y < h) {
      ellipse(p.x, y, 2, 2);
      y += 10;
    }
  }
  fill(143, 27, 10, 200);
  stroke(231, 120, 58, 200);
  strokeWeight(6);
  zonoid_vertices_u_temp = zonoid_vertices_u.map(function(p) {
    return new Point(p.x * scale_factor, p.y * scale_factor);
  });
  if (zonoid_vertices_u_temp.length > 1) {
    for (i = o = 1, ref3 = zonoid_vertices_u_temp.length - 1; 1 <= ref3 ? o <= ref3 : o >= ref3; i = 1 <= ref3 ? ++o : --o) {
      line(zonoid_vertices_u_temp[i - 1].x, zonoid_vertices_u_temp[i - 1].y, zonoid_vertices_u_temp[i].x, zonoid_vertices_u_temp[i].y);
    }
  }
  strokeWeight(2);
  for (q = 0, len2 = zonoid_vertices_u_temp.length; q < len2; q++) {
    p = zonoid_vertices_u_temp[q];
    ellipse(p.x, p.y, 20, 20);
  }
  if (zonoid_vertices_u_temp.length > 1) {
    for (i = r = 1, ref4 = zonoid_vertices_u_temp.length - 1; 1 <= ref4 ? r <= ref4 : r >= ref4; i = 1 <= ref4 ? ++r : --r) {
      zonoid_slice_u = [zonoid_vertices_u_temp[i - 1], zonoid_vertices_u_temp[i], new Point(zonoid_vertices_u_temp[i].x, 10000), new Point(zonoid_vertices_u_temp[i - 1].x, 10000)];
      draw_poly(radial_sort(zonoid_slice_u, {
        anchor: leftmost_point(zonoid_slice_u),
        cw: true
      }), {
        fill_color: [231, 120, 58, 40],
        stroke_color: [16, 74, 34, 0]
      });
    }
  }
  fill(98, 122, 161, 200);
  stroke(21, 32, 50, 200);
  k_level_d_temp = k_level_d.map(function(p) {
    return new Point(p.x * scale_factor, p.y * scale_factor);
  });
  for (i = s = 1, ref5 = k_level_d_temp.length - 1; 1 <= ref5 ? s <= ref5 : s >= ref5; i = 1 <= ref5 ? ++s : --s) {
    strokeWeight(6);
    line(k_level_d_temp[i - 1].x, k_level_d_temp[i - 1].y, k_level_d_temp[i].x, k_level_d_temp[i].y);
  }
  strokeWeight(2);
  ref6 = reflex_vertices_d.map(function(p) {
    return new Point(p.x * scale_factor, p.y * scale_factor);
  });
  for (t = 0, len3 = ref6.length; t < len3; t++) {
    p = ref6[t];
    fill(98, 122, 161, 200);
    stroke(21, 32, 50, 200);
    ellipse(p.x, p.y, 20, 20);
    y = p.y - 15;
    fill(default_color);
    stroke(default_color);
    strokeWeight(2);
    while (y > 0) {
      ellipse(p.x, y, 2, 2);
      y -= 10;
    }
  }
  fill(98, 122, 161, 200);
  stroke(21, 32, 50, 200);
  strokeWeight(6);
  zonoid_vertices_d_temp = zonoid_vertices_d.map(function(p) {
    return new Point(p.x * scale_factor, p.y * scale_factor);
  });
  if (zonoid_vertices_d_temp.length > 1) {
    for (i = u = 1, ref7 = zonoid_vertices_d_temp.length - 1; 1 <= ref7 ? u <= ref7 : u >= ref7; i = 1 <= ref7 ? ++u : --u) {
      line(zonoid_vertices_d_temp[i - 1].x, zonoid_vertices_d_temp[i - 1].y, zonoid_vertices_d_temp[i].x, zonoid_vertices_d_temp[i].y);
    }
  }
  strokeWeight(2);
  for (v = 0, len4 = zonoid_vertices_d_temp.length; v < len4; v++) {
    p = zonoid_vertices_d_temp[v];
    ellipse(p.x, p.y, 20, 20);
  }
  if (zonoid_vertices_d_temp.length > 1) {
    for (i = x = 1, ref8 = zonoid_vertices_d_temp.length - 1; 1 <= ref8 ? x <= ref8 : x >= ref8; i = 1 <= ref8 ? ++x : --x) {
      zonoid_slice_d = [zonoid_vertices_d_temp[i - 1], zonoid_vertices_d_temp[i], new Point(zonoid_vertices_d_temp[i].x, -10000), new Point(zonoid_vertices_d_temp[i - 1].x, -10000)];
      draw_poly(radial_sort(zonoid_slice_d, {
        anchor: leftmost_point(zonoid_slice_d),
        cw: true
      }), {
        fill_color: [21, 32, 50, 40],
        stroke_color: [16, 74, 34, 0]
      });
    }
  }
  draw_poly([new Point(w / 2, 0), new Point(w, 0), new Point(w, h), new Point(w / 2, h)], {
    fill_color: [255, 251, 234, 255],
    stroke_color: [0, 0, 0, 0]
  });
  stroke(143, 114, 93, 120);
  strokeWeight(6);
  line(w / 2, 0, w / 2, h);
  stroke("black");
  strokeWeight(1);
  fill(85, 185, 102, 60);
  stroke(17, 74, 27, 180);
  ref9 = input_points.map(function(p) {
    return new Point(p.x * (scale_factor * 2) + w * 0.75, p.y * scale_factor + 100);
  });
  for (z = 0, len5 = ref9.length; z < len5; z++) {
    p = ref9[z];
    ellipse(p.x, p.y, 10, 10);
  }
  stroke(143, 114, 93, 200);
  ref10 = zonoid_lines.map(function(l) {
    return [new Point(l.start.x * (scale_factor * 2) + w * 0.75, l.start.y * scale_factor + 100), new Point(l.end.x * (scale_factor * 2) + w * 0.75, l.end.y * scale_factor + 100)];
  });
  for (i1 = 0, len6 = ref10.length; i1 < len6; i1++) {
    l_i = ref10[i1];
    line(l_i[0].x, l_i[0].y, l_i[1].x, l_i[1].y);
  }
  zonoid_temp = zonoid.map(function(p) {
    return new Point(p.x * (scale_factor * 2) + w * 0.75, p.y * scale_factor + 100);
  });
  for (j1 = 0, len7 = zonoid_temp.length; j1 < len7; j1++) {
    z_i = zonoid_temp[j1];
    fill(16, 74, 34, 180);
    stroke(16, 74, 34, 255);
    ellipse(z_i.x, z_i.y, 20, 20);
    ellipse(z_i.x, z_i.y, 10, 10);
  }
  if (zonoid_temp.length > 0) {
    return draw_poly(radial_sort(zonoid_temp, {
      anchor: leftmost_point(zonoid_temp),
      cw: true
    }), {
      fill_color: [78, 185, 120, 160],
      stroke_color: [16, 74, 34, 255]
    });
  }
};

mouseWheel = function(event) {
  var j, len, p_i, zonoid_dual_vertices;
  if (event.delta > 0) {
    k -= 1;
  } else if (event.delta < 0) {
    k += 1;
  }
  if (k < 2) {
    k = 1;
  }
  if (k > dual_lines.length) {
    k = dual_lines.length;
  }
  k_level_u = compute_k_level(dual_lines, k, {
    reverse: true
  });
  reflex_vertices_u = compute_reflex_vertices(k_level_u, {
    up: false
  });
  zonoid_vertices_u = compute_zonoid_vertices_from_reflex(reflex_vertices_u, dual_lines, {
    up: false
  });
  k_level_d = compute_k_level(dual_lines, dual_lines.length - k + 1, {
    reverse: true
  });
  reflex_vertices_d = compute_reflex_vertices(k_level_d, {
    up: true
  });
  zonoid_vertices_d = compute_zonoid_vertices_from_reflex(reflex_vertices_d, dual_lines, {
    up: true
  });
  zonoid_dual_vertices = zonoid_vertices_u.concat(zonoid_vertices_d);
  zonoid_lines = [];
  for (j = 0, len = zonoid_dual_vertices.length; j < len; j++) {
    p_i = zonoid_dual_vertices[j];
    zonoid_lines.push(new Line(new Point(-10000, -p_i.x * -10000 + p_i.y), new Point(10000, -p_i.x * 10000 + p_i.y), -p_i.x, p_i.y));
  }
  zonoid = compute_zonoid(input_points, {
    k: k - 1
  });
  return console.log("K: ", k);
};

draw_poly = function(points, arg) {
  var fill_color, j, len, p_i, ref, stroke_color;
  ref = arg != null ? arg : {}, fill_color = ref.fill_color, stroke_color = ref.stroke_color;
  if (fill_color == null) {
    fill_color = default_color;
  }
  if (stroke_color == null) {
    stroke_color = default_color;
  }
  fill(fill_color[0], fill_color[1], fill_color[2], fill_color[3]);
  stroke(stroke_color[0], stroke_color[1], stroke_color[2], stroke_color[3]);
  beginShape();
  for (j = 0, len = points.length; j < len; j++) {
    p_i = points[j];
    vertex(p_i.x, p_i.y);
  }
  endShape(CLOSE);
  fill("black");
  return stroke("black");
};

leftmost_point = function(S) {
  var j, leftmost_p, len, p, ref;
  leftmost_p = S[0];
  ref = S.slice(1, +(S.length - 1) + 1 || 9e9);
  for (j = 0, len = ref.length; j < len; j++) {
    p = ref[j];
    if (p.x < leftmost_p.x) {
      leftmost_p = p;
    }
  }
  return leftmost_p;
};

rightmost_point = function(S) {
  var j, len, p, ref, rightmost_p;
  rightmost_p = S[0];
  ref = S.slice(1, +(S.length - 1) + 1 || 9e9);
  for (j = 0, len = ref.length; j < len; j++) {
    p = ref[j];
    if (p.x > rightmost_p.x) {
      rightmost_p = p;
    }
  }
  return rightmost_p;
};

translate_p = function(p) {
  return new Point(p.x * scale_factor + w / 2, p.y * scale_factor);
};
